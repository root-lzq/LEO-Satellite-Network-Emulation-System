#!/usr/bin/python3.6

from multiprocessing import Pool
from datetime import datetime
import os
import concurrent.futures

def name_id(number):
    # 获取容器短id
    #【参数】number : int
    # 【返回值】result: string

    import subprocess
    string = ' "name=^b' + str(number) + '$"'
    total_string = "docker ps -aqf{}".format(string)
    result=subprocess.getoutput(total_string)
    return result

def list_id(n):
    # 生成n个容器的短id数组
    #【参数】n : 容器数量；int
    #【返回值】list_namd_id : 容器短id的string数组,每个元素对应一个容器的短id

    list_name_id=[]
    for i in range(n):    #[0,1599]
        list_name_id.append(name_id(i+1))
    return list_name_id    # ID [b1 ^ bn]

def qdl(list_delay):
    #为每个容器的网卡建立时延队列
    #【参数】list_delay : 时延string数组，每一行是时延矩阵的一行
    
    #test_num = len(list_delay)
    for i in range(60): #遍历每个元素
         list_delay_split = list_delay[i].split() # 以空格为分割符，获得时延矩阵的每一行的时延参数数组
         output_list = []

         for j in range(len(list_delay_split)):
             if list_delay_split[j] != '0.00000':
                 output_list.append(j) #out_put存储时延不为0的元素序列号（ j>=0）; int
         
         #docker_id_now = docker_id[i] #获取当墙容器的短id
         docker_id_now = name_id(i+1)

         pre_command = 'ip netns exec ' + docker_id_now #前缀命令

         #建立带宽时延队列
         os.system( pre_command + ' tc qdisc del dev eth0 root')
         os.system( pre_command + ' tc qdisc add dev eth0 handle 1: root htb')

         #print(pre_command + ' tc qdisc del dev eth0 root')
         #print(pre_command + ' tc qdisc add dev eth0 handle 1: root htb')
         
         for m in range(len(output_list)):
             bandwidth_class = pre_command +' tc class add dev eth0 parent 1: classid 1:'+str(m+1)+' htb rate 10mbit ceil 10mbit'
             os.system(bandwidth_class)
             #print(bandwidth_class)
             
             delay = int(float(list_delay_split[output_list[m]]) * 1000)
             delay_qdisc = pre_command+' tc qdisc add dev eth0 parent 1:' +str(m+1)+" handle "+str(10*(m+1))+": netem delay "+str(delay)+"ms"
             os.system(delay_qdisc)
             #print(delay_qdisc)

             ip_now = '10.0.'+str(int( (output_list[m]+1) / 254)) + '.'+ str( (output_list[m]+1) % 254 + 1)
             filter_ip = pre_command+' tc filter add dev eth0 protocol ip parent 1:0 u32 match ip dst '+ ip_now +" flowid 1:"+str(m+1)
             os.system(filter_ip)
             #print(filter_ip)


def mul_qdl(i):
         list_delay_split = list_delay[i].split() # 以空格为分割符，获得时延矩阵的每一行的时延参数数组
         output_list = []

         for j in range(len(list_delay_split)):
             if list_delay_split[j] != '0.00000':
                 output_list.append(j) #out_put存储时延不为0的元素序列号（ j>=0）; int

         #docker_id_now = docker_id[i] #获取当墙容器的短id
         docker_id_now = name_id(i+1)

         pre_command = 'ip netns exec ' + docker_id_now #前缀命令

         #建立带宽时延队列
         os.system( pre_command + ' tc qdisc del dev eth0 root')
         os.system( pre_command + ' tc qdisc add dev eth0 handle 1: root htb')
         #print(pre_command + ' tc qdisc del dev eth0 root')
         #print(pre_command + ' tc qdisc add dev eth0 handle 1: root htb')


         for m in range(len(output_list)):
             bandwidth_class = pre_command +' tc class add dev eth0 parent 1: classid 1:'+str(m+1)+' htb rate 10mbit ceil 10mbit'
             os.system(bandwidth_class)
             #print(bandwidth_class)

             delay = int(float(list_delay_split[output_list[m]]) * 1000)
             delay_qdisc = pre_command+' tc qdisc add dev eth0 parent 1:' +str(m+1)+" handle "+str(10*(m+1))+": netem delay "+str(delay)+"ms"
             os.system(delay_qdisc)
             #print(delay_qdisc)

             ip_now = '10.0.'+str(int( (output_list[m]+1) / 254)) + '.'+ str( (output_list[m]+1) % 254 + 1)
             filter_ip = pre_command+' tc filter add dev eth0 protocol ip parent 1:0 u32 match ip dst '+ ip_now +" flowid 1:"+str(m+1)
             os.system(filter_ip)
             #print(filter_ip)

dt=datetime.now()
num=dt.hour*60+dt.minute

#docker_id = list_id(len(list_delay)) #获取当前所有容器短id的string数组



while True:
    flag=num
    dt=datetime.now()
    num=dt.hour*60+dt.minute+1
    if flag==num:
       continue

    file_delay='/root/1600_delay/'+str(num)+'.txt'
    list_delay =[] #时延数组，每一行是时延矩阵的一行

    with open(file_delay, 'r+', encoding='utf-8') as file_obj:
        for content in file_obj:
             out_put = content.rstrip()
             if len(out_put):
                 list_delay.append(out_put)
   
    #qdl(list_delay)

    list_order = []

    for i in range(60):
        list_order.append(i)

    with Pool(60) as pool:
         pool.map(mul_qdl, list_order)

            
    flag=num
    print('-----------------'+str(num)+'---------'+str(num)+'--------------------------------------')

